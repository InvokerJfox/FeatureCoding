from encode.iscs.calculator.OperateTarget import *
from encode.iscs.entry.target.Target import Target

from encode.code import OperationCompressed

"""
     非优化转化(品质:list(值1)→list(值2))
"""

'''
    该维度描述消费物状态时,具有以下特征:
    1.离散的有效值(值,未知);
    2.不存在集合值(任意,已知等);

    该维度描述子目标变化时,起止维度均具有以下特征:
    1.离散的有效值(值,未知);
    2.目标可以包含多个<变化方式>的集合
        集合值间为'或'关系
    3.通过集合(任意,已知等向量)合并描述相同的<变化方式>;


    该维度在作业过程中,具有以下特征:
    1.通过<作业方式>将<状态1>的消费物改变为<状态2>的消费物;
    2.一个作业点同时具有若干<作业方式>,一次作业使用一种<作业方式>;
    3.通过集合(向量)合并描述相同的作业方式:
        第一维为不变操作,合并所有可操作物;
        其余维是基于相同起始选取操作或相同目标获取操作的合并压缩;
        集合值间为或关系;
    4.不具有成本约束;

'''
'''
     作业-品质转化方式
        作业点1:
            (约束)可操作:
                未知|良|次|废
            (推论)可获取:
                良|合格|次|废
            作业方式:
                [(未知|良→已知={良|合格|次|废}),(未知|次|废→合格|废)]
        作业点2:
            (约束)可操作:
                良|合格
            (推论)可获取:
                合格
            作业方式:
                [(良|合格→合格)]
        作业点3:
            (约束)可操作:
                次|废
            (推论)可获取:
                废
            作业方式:
                [(次|废→废)]
        作业点4:
            (约束)可操作:
                已知={良|合格|次|废}
            (推论)可获取:
                已知={良|合格|次|废}
            作业方式:
                []

        '或'关系表示若干变量之一
     完全的离散状态=未知、良、合格、次、废
     自定义集合状态=任意(所有离散状态)、已知(不含未知的任意)等
'''
'''
    不妨编码为:
        未知 = 00001,良=00010,合格 = 00100,次 = 01000,废 = 10000,
        未知|良 = 00001|00010 = 00011
        已知 = 良|合格|次|废 = 11110
        未知|次|废 = 00001|01000|10000 = 11001
        合格|废 = 00100|10000 = 10100
        良|合格 = 00010|00100 = 00110
        次|废 = 01000|10000 = 11000
    新建简易(非优化)转化特征:
        作业点1:
            input=[11111];#所有值均可操作,但不可不可改变合格品的品质
            ops = [[(00011,11110)],[(11001,10100)]];
            #output = [];
        作业点2:
            input=[00110];#仅操作良与合格品
            ops = [[(00110,00100)]];
            #output = [];
        作业点3:
            input=[11000];
            ops = [[(11000,10000)]];
            #output = [];
        作业点4:
            input=[11111];
            ops = [];
            output = [];
    判断函数:
        求解子目标在作业点可达成:
            not ((origin - (origin & input)) or (target - (target & output)))
        求解递归的可选状态(图论):
            作业点连接关系:

    example:
        求解子目标在作业点1可达成:
            1.未知→已知:origin=(00001)→target(11110)
            2.次→合格:origin=(01000)→target(00100)
            3.未知→合格|废:origin=(00001)→target(10100)
            4.良→良:origin=(00010)→target(00010)
            5.未知|良|次→废|次|合格:origin=(01011)→target(11100)
        求解递归的可选状态:
            作业点1→作业点2:
            origin()→state()→target()
            作业点2→作业点1:
            origin()→state()→target()
'''

if __name__ == '__main__':
    target = Target([0b000000, [0b000001, 0b010000]])
    # operation 等价于作业点能力
    cop1 = OperationCompressed(merge_compress_ops([[0b000001, 0b000001], [0b000010, 0b000010], [0b000100, 0b000100],
                                                   [0b001000, 0b001000], [0b000001, 0b100000], [0b000010, 0b000100]]))

    cop2 = OperationCompressed(merge_compress_ops([[0b100000, 0b100000], [0b010000, 0b010000], [0b100000, 0b010000]]))
    cop3 = OperationCompressed(merge_compress_ops([[0b000100, 0b000001]]))

    print(cop1.test_dimension_operation)
    print(cop2.test_dimension_operation)
    print(cop3.test_dimension_operation)

    res = operate_target(target.test_dimension_change, cop1.test_dimension_operation)

    print(res)
